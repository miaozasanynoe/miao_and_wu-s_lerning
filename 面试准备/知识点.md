#### HashMAp：
    一个数组，下面牵着链表，如果链表超过8就会变成红黑树。
#### B树，B+树
    BS
#### 数据库索引
#### 聚集索引和非聚集索引
    聚簇索引是顺序结构与数据存储物理结构一致的一种索引，并且一个表的聚簇索引只能有唯一的一条；
    非聚簇索引记录的物理顺序与逻辑顺序没有必然的联系，与数据的存储物理结构没有关系；一个表对应的非聚簇索引可以有多条，根据不同列的约束可以建立不同要求的非聚簇索引；
#### Linux查看文件第n行
#### Linux文件系统原理
#### 类加载过程
    1.加载阶段：
        1.1通过全限定名获取二进制流
        1.2将字节流转化为方法区运行时的数据结构
        1.3在方法区加载这个类的java.lang.Class对象
    2.链接
        2.1 验证：对文件格式，元数据，字节码，符号引用进行验证(CAFYBABE)
        2.2 准备：静态变量赋初始值，finnal赋值，引用对象为null
        2.3 解析：符号引用转化为直接引用
    3.初始化：
        3.1：<clinit>：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行

        3.2：<init>:在实例创建出来的时候调用，包括调用new操作符；调用Class或Java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。
#### 双亲委派机制
    类加载器的类别：
    1.BootstrapClassLoader(引导类加载器)
    2.ExtClassLoader(扩展类加载器)
    3.AppClassLoader(系统类加载器)
    4.CustomClassLoader(自定义类加载器)
    作用：1.防止重复加载一个类
        2.保证核心类不被修改(例如Object类)
#### JVM内存
> 线程共享区:
 
>1. 方法区  

    方法区，也称非堆（Non-Heap），是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据，。另外，方法区包含了一个特殊的区域“运行时常量池”  
    
    运行时常量池:
    常量池用于存放在字节码中使用到的所有字面量和符号引用（如字符串字面量），在类加载时，它们进入方法区的运行时常量池存放。

    　　运行时常量池是方法区中一个比较特殊的部分，具备动态性，也就是说，除了类加载时将常量池写入其中，java程序运行期间也可以向其中写入常量：


```
String str = new StringBuilder("abc");
str.intern();
//使用StringBuilder在堆上创建字符串abc，再使用intern将其放入运行时常量池
String str2 = "xyz";
//直接使用字符串字面量xyz，其被放入运行时常量池
```
>2. Java堆
    新生代，老年代
元空间
> 线程独占区：

>1.虚拟机栈  

    栈帧:  
    a.局部变量表:  
    数组实现、没有安全问题、容量大小在编译期确定(字节码中：Maximun local variable)、this的引用放在index=0、可以复用。
    b.操作数栈：  
    0地址指令、容量大小编译期确定、调用的方法压入栈中、<Clinit>、<Init>
    c.动态链接：主要作用是将符号引用转化为直接引用
        静态链接(早期绑定)：
        nvokespecial: 调用一个初始化(构造)方法，私有方法或者父类的方法  
        invokestatic:调用静态方法
        动态链接(晚期绑定)：
        invokevirtual:调用实例方法
        invokeinterface：调用接口方法invoke
    d.方法返回地址:记录调用该方法的程序计数器值
    f.附加信息


    -Xss来给虚拟机栈分配内存
>2.本地方法栈  
naive方法执行的区域，snaphot虚拟机合二为一

>3.程序计数器

    1.程序计数器的定义
    程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为Undefined。

    2.程序计数器的作用
    字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。
    在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。

    3.程序计数器的特点
     是一块较小的内存空间。
     线程私有，每条线程都有自己的程序计数器。
     生命周期：随着线程的创建而创建，随着线程的结束而销毁。
     是唯一一个不会出现OutOfMemoryError的内存区域。

#### 三次握手，四次挥手
![三次](https://upload-images.jianshu.io/upload_images/7368936-abf0a9b7fc6c8eb3.png?imageMogr2/auto-orient/strip|imageView2/2/w/470/format/webp)

![四次](https://upload-images.jianshu.io/upload_images/7368936-69a8f8961771337b.png?imageMogr2/auto-orient/strip|imageView2/2/w/426/format/webp)

挥手为什么需要四次？
因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

四次挥手释放连接时，等待2MSL的意义
为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

#### 进程和线程，区别，哪个效率高，为什么
    1.进程有独立的堆，数据区，而线程没有
    2.进程包含多个线程，线程只能属于一个进程
    3.线程效率高一些，因为在上下文切换的时候进程开销大一些
#### 幻读
    幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了  
    从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。  

    　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。
#### 死锁的条件，如何解决
>条件
1.  互斥条件
    即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。


2.  不可抢占条件。
    进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。
3.  占有且申请条件。
    进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。


4.  循环等待条件
    存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。

>解决方法

1.  破坏互斥条件

2.  破坏不可抢占条件。
    可抢占式，即要求申请失败的进程释放自己占有的资源给别人用，降低系统性能。

3.  破坏占有且申请条件。

    直接申请自己所需要的所有资源。--1.不可预知自己需要什么资源 2.资源利用率低，长期占有自己可能不用的资源。

4.  破坏循环等待条件

    资源分类、编号，按序申请。 --·1.编号可能是困难的，维护相应的序列是困难的




> 死锁的避免

    死锁的避免是指不限制进程有关申请资源的命令,而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。  
1.  银行家算法。当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。
#### java的基本数据类型和字节数
    int------Interger---4
    short----Short------2
    double---Double-----8
    char-----Char-------2
    byte-----Byte-------1
    long-----Long-------8
    float----Float------4
    boolean--Boolean----1
#### 注解
注解本质上是继承了 Annotation 接口的接口，而当你通过反射，也就是我们这里的 getAnnotation 方法去获取一个注解类实例的时候，其实 JDK 是通过动态代理机制生成一个实现我们注解（接口）的代理类。
#### Java，volatile关键字
锁的粒度小，只会在store加锁。
保证可见性
只能保证对单次读/写的原子性
防止重排序保证有序性
有volatile变量修饰的共享变量进行写操作的时候会多一行有lock前缀的指令，作用是

1.将当前处理器缓存行的数据会写回到系统内存。  
2.这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。()
#### 进程如何同步
1.  临界区（Critical Section）:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。  
    优点：保证在某一时刻只有一个线程能访问数据的简便办法
    缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。


2.  互斥量（Mutex）:为协调共同对一个共享资源的单独访问而设计的。

    互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。

    优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。

    缺点：  
    ①互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。

    ②通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。

 

3.  信号量（Semaphore）:为控制一个具有有限数量用户资源而设计。它允  许    

    优点：适用于对Socket（套接字）程序中线程的同步。（例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。）

    缺点：   
    ①信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点；

    ②信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；

    ③核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。

 

4.  事件（Event）: 用来通知线程有一些事件已发生，从而启动后继任务的开始。

    优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。
>Java内存模型  

1. currentThread()
返回对当前正在执行的线程对象的引用。

2. getId()
返回此线程的、

3. getName()
返回此线程的名称

4. getPriority()
返回此线程的优先级

5. isAlive()
测试这个线程是否还处于活动状态。
什么是活动状态呢？
活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。

6. sleep(long millis)
使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。

7. interrupt()
中断这个线程。

8. interrupted() 和isInterrupted()
interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能  
isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但部清楚状态标志

9. setName(String name)
将此线程的名称更改为等于参数 name 。

10. isDaemon()
测试这个线程是否是守护线程。

11. setDaemon(boolean on)
将此线程标记为 daemon线程或用户线程。

12. join()
在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是 主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。  
join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行

13. yield()
yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。

14. setPriority(int newPriority)
更改此线程的优先级
#### mysql索引结构，特点，为什么使用这个
>索引结构  

    B-tree
>特点

#### 如果查询比较高效
#### String，StringBuffer，StringBuilder区别
    String 字符串常量
    StringBuffer 字符串变量（线程安全）
    StringBuilder 字符串变量（非线程安全）
#### HashMap，为什么使用红黑树
#### 垃圾回收机制GC，cms，G1，垃圾回收的算法
#### TCP连接和释放
#### 子类和父类的实例变量和方法有什么区别
#### 重载和覆盖区别，返回值类型不同，可以重载吗，为什么，底层如何实现的
    1.重载是参数不同名称与返回值相同
    2.重写是返回值与参数都不能变
#### java多线程，状态图，画出来，阻塞的状态有哪几种，运行顺序，多线程的一些方法
#### java泛型
    参数化类型
#### mysql join的底层原理是什么，有哪几种（不是左右连接这种）
linux命令查询一个文件内出现重复最多的数字的
linux命令查询一个文件的行数
#### 悲观锁和乐观锁
    乐观锁：CAS，版本号
    悲观锁：加锁
#### @Transaction的原理，还有比如在一个类中两个方法，一个是B方法，一个是C方法，B上没有注解，C上有那么在外面调用B方***有事务，为什么，根据底层原理能不能推断出来（给提示问你能不能推断出来）
#### 查询学生成绩不及格的所有人的姓名和编号，根据这个语句，如何建立索引，为什么，
#### mysql底层是什么，为什么效率高，主键能不能太大，为什么，如果太大，底层数据结构会不会变化，为什么
#### 操作系统为什么有用户态和内核态，用户级线程与内核级线程如何转换
#### 场景题：5000人同时执行转账，编写线程时要注意什么？没学过数据库没关系，可以认为数据在内存中（穿插着问了死锁）
#### 场景题：抖音有十亿用户，32字节的userid和double类型的活跃度数据，保存在1000个文件中每个文件100万行。找出这些文件中活跃度最高的10000个玩家的userid和活跃度的数值（穿插着问了堆的实现）
#### 说一下Map的各种实现类，它们有什么区别
    HashMap，HashTable,currentHashMap,treeMap,LinkedHashMap

#### HashMap底层实现
    数组+链表(红黑树)
#### Spring中的Bean生命周期，Spring初始化过程
Spring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：
四个阶段

1. 实例化 Instantiation
2. 属性赋值 Populate
3. 初始化 Initialization
4. 销毁 Destruction

##### 多个扩展点

1. 影响多个Bean  
2. BeanPostProcessor  
3. InstantiationAwareBeanPostProcessor  
##### 影响单个Bean  
1. Aware  
    Aware Group1  
        1.1 BeanNameAware  
        1.2 BeanClassLoaderAware  
        1.3 BeanFactoryAware  
    Aware Group2  
        1.1 EnvironmentAware  
        1.2 EmbeddedValueResolverAware  
        1.3 ApplicationContextAware  (ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)  
2. 生命周期  
        2.1 InitializingBean  
        2.2 DisposableBean  

#### 数据库中的组合索引，数据库优化有了解过吗
#### 快排，时间空间复杂度
    O(nLogN)
#### Servlet是单线程还是多线程的，线程安全吗
    多线程
    线程不安全
springboot的优势、介绍一下springboot
10.hash冲突了解哪些？说一下hashmap里的hash冲突，红黑树的定义，put一个元素到红黑树里红黑树的转变过程
4.MyISAM应用场景，什么引擎支持事务？
如果我的系统很慢，从数据库方面怎么优化？
linux中常用命令，如果查一个目录下文件中包含“xxxx”的个数，命令是什么？
8.平时命令怎么查？让没事多看看help。
9.负载均衡说一下，nginx的负载均衡策略
10.Java中的多线程？会造成什么问题？
11.对语言排斥吗？为什么？
#### 什么是生产者消费者模式，举个场景、
    解藕，支持闲忙不均，支持并发

#### 设计表结构  怎么实现用户量大的情况下快速查询用户的粉丝数/关注数
    在用户表中增加字段记录粉丝数和关注数(不知道可不可以)

#### 7.IOC加载过程
#### wait和sleep的区别
    wait释放锁，一般用于线程通信
    sleep不会，一般用于暂停
#### synchronized底层原理  是可重入锁吗
#### CAS原理  -> java内存模型   CAS会有什么问题
#### 怎么解决ABA问题
#### HashMap数据结构 线程安全吗
#### 举个例子HashMap怎么线程不安全
#### 数据库索引怎么建立，把你的认识说出来，后来我引到了聚簇索引，索引覆盖
#### 解释什么是索引覆盖
#### 数据库隔离级别有哪些
#### 除了设置数据库隔离级别，还有什么方法可以解决不可重复读 (后面提示说这个有个专有的名词)
#### 讲讲滑动窗口的过程 滑动窗口在哪里用到
#### 互斥锁和同步锁（看到过，但是没有准备，所以靠着记忆结结巴巴的答出来了
#### 百万的数据，找出最大的 100 个
    用最小堆
    如果这 100 万个数据都是 0-100 之间的有什么其他办法，用一个大小为 100 的哈希结构存储数据
    如果数据是 100 亿，大到内存存不下怎么办，我说就分次读取
#### mysql 用的是什么数据结构存储
#### 场景设计题：抖音点赞，QPS 是百万级，如何设计
#### cookie跨域
#### 说一下jvm线程调度过程，什么情况会发生抢占
#### 说一下线程通过继承thread和实现runable接口实现的线程，底层有什么区别
#### 说一下cookie和session的区别 场景的选择
#### Java说出你知道创建字符串的方式，比较性能优劣
#### 说一下Java内存模型
#### Java内存交互操作
#### volatile如何保证数据一致性？
#### valatile的变量两个线程一起操作会发生什么？联系对象头。
#### 如果向操作系统请求一个4g的连续空间会分配吗？过程？
#### 数据库如何保证数据一致性，如何解决？


#### HashMap原理 我讲了1.7与1.8的区别，比如存储结构，扩容：头插 尾插这些。还有hashmap会出现的死循环问题。
#### 如何保证HashMap是线程安全的？讲到了CurrentHashMap的原理以及如何加锁的
#### 如何保证线程安全 讲到了synchronized关键字和lock
#### spring bean生命周期
    实例化
    依赖注入
    初始化方法->
    销毁
#### springboot启动流程
    1、run() 方法主要调用了spring容器启动方法扫描配置，加载bean到spring容器中
    2、启动的内置Web容器
#### springboot特点:

#### spring aop实现原理
#### 写sql 找出语文成绩及格平均成绩不及格的学生姓名语文成绩
select name,sc from SC s
left Join Student c where s.sno=c.sno and 
jvm如何判断对象是否可被回收，哪些可以做为GC Roots
#### 输入网址发生了哪些事情：
    1.根据域名，进行DNS域名解析，获得IP地址。
    2.根据IP地址，建立TCP连接
    3.建立TCP连接后，向IP地址发送http请求
    4服务端处理请求
    5服务端返回响应结果
    6 关闭TCP连接
    7浏览器解析HTML
    8浏览器渲染数据展示
nginx、项目部署过程
MySQL的主从复制原理，读写分离在代码层如何实现的
1、数组中每个数右边第一个比它大的元素（LeetCode 1019）
2、二叉树的最近公共祖先（LeetCode 236）

#### 树的三种遍历
    先序遍历
    中序遍历
    后序遍历
##数据库
进程和线程，区别，哪个效率高，为什么
#### MySQL的主从复制原理，读写分离在代码层如何实现的
#### InnoDB特性
#### 事务管理（ACID）
    1.原子性（Atomicity）
    原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    ===>undo实现
    2.一致性（Consistency）
    事务前后数据的完整性必须保持一致。
    ===>其他三者实现
    3.隔离性（Isolation）
    事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
    ====>锁,MVVC
    4.持久性（Durability）
    持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响
    ===>redo
![redo file](https://images2018.cnblogs.com/blog/733013/201805/733013-20180508104623183-690986409.png)
#### 事务隔离级别
    1.脏读
    2.不可重复读
    3.幻读
    ===========================================================================================
        隔离级别               脏读（Dirty Read）          不可重复读（NonRepeatable Read）     幻读（Phantom Read）
    ===========================================================================================

    未提交读（Read uncommitted）        可能                            可能                      可能

    已提交读（Read committed）          不可能                          可能                      可能

    可重复读（Repeatable read）         不可能                          不可能                     可能

    可串行化（Serializable ）           不可能                          不可能                     不可能

    ===========================================================================================
#### 读写锁
>1.共享锁（S锁）
    
    可读不可写
```
select * from student where id=1 for share
```
>2.排他锁（X锁）
    
    不可读写
```
select * from student where id=1 for update
```

